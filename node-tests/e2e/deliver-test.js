const expect = require('chai').expect;
const denodeify = require('denodeify');
const request = denodeify(require('request'));
const AddonTestApp = require('ember-cli-addon-tests').AddonTestApp;
const fs = require('fs-extra');

const CSP_META_TAG_REG_EXP = /<meta http-equiv="Content-Security-Policy" content=".*">/i;

let defaultConfig;
async function setConfig(app, configData) {
  let configPath = app.filePath('config/environment.js');

  // store the untouched config generated by ember blueprint
  // on first run and reuse for all others to prevent leaking
  // between tests
  if (!defaultConfig) {
    defaultConfig = await fs.readFile(configPath, 'utf8');
  }

  // convert given object to a JavaScript source code string
  // that could be injected into config
  let customConfig = Object.keys(configData).map((key) => {
    let value = configData[key];
    return `ENV['${key}'] = ${JSON.stringify(value)}`;
  }).join("; ");

  let config = defaultConfig.replace(
    'return ENV;',
    `${customConfig}; return ENV;`
  );

  await fs.writeFile(configPath, config);
}

describe('e2e: delivers CSP as configured', function() {
  this.timeout(300000);

  let app;

  before(async function() {
    app = new AddonTestApp();

    await app.create('default', { noFixtures: true });
  });

  // Server isn't shutdown successfully if `app.startServer()` and `app.stopServer()`
  // are not wrapped inside a describe block. Therefore all tests after the first one
  // fail with a "Port 49741 is already in use" error.
  describe('', function() {
    afterEach(async function() {
      await app.stopServer();
    });

    it('creates a CSP meta tag if `delivery` option includes `"meta"`', async function() {
      await setConfig(app, {
        'ember-cli-content-security-policy': {
          delivery: ["meta"],
        }
      });

      await app.startServer();

      let response = await request({
        url: 'http://localhost:49741',
        headers: {
          'Accept': 'text/html'
        }
      });

      expect(response.body).to.match(CSP_META_TAG_REG_EXP);
    });
  });

  describe('', function() {
    afterEach(async function() {
      await app.stopServer();
    });

    it('uses Content-Security-Policy-Report-Only header if `reportOnly` option is `true`', async function() {
      await setConfig(app, {
        'ember-cli-content-security-policy': {
          delivery: ['header'],
          reportOnly: true,
        }
      });

      await app.startServer();

      let response = await request({
        url: 'http://localhost:49741',
        headers: {
          'Accept': 'text/html'
        }
      });

      expect(response.headers).to.include.key('content-security-policy-report-only');
      expect(response.headers).to.not.have.key('content-security-policy');
    });
  });

  describe('', function() {
    afterEach(async function() {
      await app.stopServer();
    });

    it('does not deliver CSP if `enabled` option is `false`', async function() {
      await setConfig(app, {
        'ember-cli-content-security-policy': {
          enabled: false,
        }
      });

      await app.startServer();

      let response = await request({
        url: 'http://localhost:49741',
        headers: {
          'Accept': 'text/html'
        }
      });

      expect(response.headers).to.not.have.key('content-security-policy');
      expect(response.headers).to.not.have.key('content-security-policy-report-only');
      expect(response.body).to.not.match(CSP_META_TAG_REG_EXP);
    });
  });
});
